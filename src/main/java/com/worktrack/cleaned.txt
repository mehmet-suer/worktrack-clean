package com.worktrack.dto.response.project;



public record ProjectResponse(
        Long id,
        String name,
        String description,
        String ownerFullName,
        String ownerUsername,
        Instant createdAt,
        Integer version,
        Status status,
        String createdBy,
        String updatedBy
) {
}

package com.worktrack.dto.response.project;


public record TaskResponse(Long id, String title, String description, TaskStatus status) {}

package com.worktrack.dto.response;


public record LoginResponse(
        String token,
        TokenType type,
        long expiresAt
) { }
package com.worktrack.dto.response;

public class ErrorResponse {
    private final String code;
    private final String message;


    public ErrorResponse(String code, String message) {
        this.code = code;
        this.message = message;
    }
    public String getCode() {
        return code;
    }

    public String getMessage() {
        return message;
    }
}
package com.worktrack.dto.security;

public enum TokenType {
    BEARER,
    REFRESH;
}
package com.worktrack.dto.security;

public record GeneratedToken(
    String token,
    TokenType type,
    long expiresAt
){}
package com.worktrack.dto.request.auth;


public class UserRegistrationRequest {

    @NotBlank
    @Size(min = 3, max = 50)
    private String username;

    @NotBlank
    @Email
    private String email;

    @NotBlank
    @Size(min = 6, message = "Password must be at least 6 characters")
    private String password;

    private String fullName;

    @NotNull
    private Role role;

    // === Constructors ===
    public UserRegistrationRequest() {
    }

    public UserRegistrationRequest(String username, String email, String password, String fullName, Role role) {
        this.username = username;
        this.email = email;
        this.password = password;
        this.fullName = fullName;
        this.role = role;
    }

    // === Getters and Setters ===
    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getFullName() {
        return fullName;
    }

    public void setFullName(String fullName) {
        this.fullName = fullName;
    }

    public Role getRole() {
        return role;
    }

    public void setRole(Role role) {
        this.role = role;
    }
}
package com.worktrack.dto.request.auth;
public record LoginRequest(String username, String password) {}package com.worktrack.dto.request.auth;


public record UserUpdateRequest(

        @Size(min = 3, max = 50)
        String username,

        @Email
        String email,

        @Size(min = 6)
        String password,

        String fullName

) {}package com.worktrack.dto.request.project;


public record CreateProjectRequest(
        @NotBlank(groups = Create.class)
        @Size(max = 255)
        String name,

        @Size(max = 255)
        String description,

        Long ownerId
) { }
package com.worktrack.dto.request.project;


public record CreateTaskRequest(String title, String description, TaskStatus status) {}package com.worktrack.dto.request.validation;

public interface Update {
}
package com.worktrack.dto.request.validation;

public interface Create {
}
package com.worktrack.infra.hibernate;



@Component
public class HibernateFilterManager {

    @PersistenceContext
    private EntityManager entityManager;

    public void enableNotDeletedFilter() {
        enableFilterWithParams("notDeleted", Map.of("deletedStatus", Status.DELETED.name()));
    }

    public void enableFilterWithParams(String filterName, Map<String, Object> params) {
        Session session = entityManager.unwrap(Session.class);
        Filter filter = session.enableFilter(filterName);
        params.forEach(filter::setParameter);
    }

}
package com.worktrack.infra.audit;



public class CustomAuditorAware implements AuditorAware<String> {

    @Override
    @NonNull
    public Optional<String> getCurrentAuditor() {
        String username = SecurityContextHolder.getContext().getAuthentication() != null
                ? SecurityContextHolder.getContext().getAuthentication().getName()
                : "system";
        return Optional.ofNullable(username);
    }
}
package com.worktrack;


@SpringBootApplication
@EnableAutoConfiguration
@EnableJpaAuditing(auditorAwareRef = "auditorAware")
public class WorktrackApplication {
	public static void main(String[] args) {
		SpringApplication.run(WorktrackApplication.class, args);
	}

}

@Configuration
public class AuditConfig {

    @Bean
    public AuditorAware<String> auditorAware() {
        return new CustomAuditorAware();
    }
}
package com.worktrack.config;


@Configuration
public class LogConfig {

    @Bean
    public CommonsRequestLoggingFilter requestLoggingFilter() {
        CommonsRequestLoggingFilter filter = new CommonsRequestLoggingFilter();
        filter.setIncludeQueryString(true);
        filter.setIncludePayload(false);
        filter.setMaxPayloadLength(10000); // body'den maksimum kaç karakter loglansın
        filter.setIncludeHeaders(false);   // header bilgisi de eklensin mi
        filter.setIncludeClientInfo(true);
        filter.setAfterMessagePrefix("REQUEST DATA: ");
        return filter;
    }
}
package com.worktrack.config;


@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthFilter;

    public SecurityConfig(JwtAuthenticationFilter jwtAuthFilter, UserDetailsService userDetailsService, PasswordEncoder passwordEncoder) {
        this.jwtAuthFilter = jwtAuthFilter;
    }


    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                .csrf(AbstractHttpConfigurer::disable)
                .sessionManagement(sess -> sess
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)) //
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/api/users/register", "api/auth/**").permitAll()
                        .anyRequest().authenticated()
                )
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
                .build();
    }

}
package com.worktrack.config;


@Configuration
public class PasswordEncoderConfig {
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}package com.worktrack.config;


@Configuration
@EnableSpringDataWebSupport(pageSerializationMode = EnableSpringDataWebSupport.PageSerializationMode.VIA_DTO)
public class SerializationConfig {
}
package com.worktrack.config;


@Configuration
@EnableConfigurationProperties(JwtProperties.class)
public class JwtConfig {
}
package com.worktrack.security.jwt;


@ConfigurationProperties(prefix = "jwt")
public record JwtProperties(String secret, long expiration) {}
package com.worktrack.security.jwt;


public interface JwtService {
    GeneratedToken generateToken(User user);
    boolean isTokenValid(String token, User user);
    String extractUsername(String token);
}
package com.worktrack.security.jwt;





@Service
public class JwtServiceImpl implements JwtService {

    private final JwtProperties jwtProperties;


    public JwtServiceImpl(JwtProperties jwtProperties) {
        this.jwtProperties = jwtProperties;
    }

    @Override
    public GeneratedToken generateToken(User user) {
        Instant now = Instant.now();
        var token= Jwts.builder()
                .subject(user.getUsername())
                .claim("role", user.getRole().name())
                .issuedAt(Date.from(now))
                .expiration(Date.from(now.plusMillis(jwtProperties.expiration())))
                .signWith(getSigningKey(), Jwts.SIG.HS256)
                .compact();
        return new GeneratedToken(token, TokenType.BEARER, System.currentTimeMillis() + jwtProperties.expiration());
    }

    @Override
    public boolean isTokenValid(String token, User user) {
        final String username = extractUsername(token);
        return username.equals(user.getUsername()) && !isTokenExpired(token);
    }

    @Override
    public String extractUsername(String token) {
        return extractAllClaims(token).getSubject();
    }

    public String extractRole(String token) {
        return (String) extractAllClaims(token).get("role");
    }

    private boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    private Date extractExpiration(String token) {
        return extractAllClaims(token).getExpiration();
    }


    private SecretKey getSigningKey() {
        byte[] keyBytes = Decoders.BASE64.decode(jwtProperties.secret());
        return Keys.hmacShaKeyFor(keyBytes);
    }

    private JwtParser jwtParser() {
        return Jwts.parser()
                .verifyWith(getSigningKey())
                .json(new JacksonDeserializer<>(Map.of()))
                .build();
    }

    public Claims extractAllClaims(String token) {
        return jwtParser().parseSignedClaims(token).getPayload();
    }

}
package com.worktrack.security.jwt;



@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtService jwtService;
    private final UserService userService;

    public JwtAuthenticationFilter(JwtService jwtService, UserService userService) {
        this.jwtService = jwtService;
        this.userService = userService;
    }


    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {

        final String authHeader = request.getHeader("Authorization");

        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }

        final String token = authHeader.substring(7);
        final String username = jwtService.extractUsername(token);

        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            userService.findByUsername(username)
                    .filter(user -> jwtService.isTokenValid(token, user))
                    .ifPresent(user -> {
                        var authToken = new UsernamePasswordAuthenticationToken(
                                user,
                                null,
                                user.getAuthorities()
                        );
                        authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                        SecurityContextHolder.getContext().setAuthentication(authToken);
                    });
        }

        filterChain.doFilter(request, response);

    }
}
package com.worktrack.security.auth;


@Component
public class AuthenticationFacadeImpl implements AuthenticationFacade{
    @Override
    public Authentication getAuthentication() {
        return SecurityContextHolder.getContext().getAuthentication();
    }

    @Override
    public String getCurrentUsername() {
        return getAuthentication().getName();
    }

    @Override
    public Long getCurrentUserId() {
        Object principal = getAuthentication().getPrincipal();
        if (principal instanceof User user) {
            return user.getId();
        }
        throw new IllegalStateException("User id bulunamadı");
    }
}
package com.worktrack.security.auth;


public interface AuthenticationFacade {
    Authentication getAuthentication();
    String getCurrentUsername();
    Long getCurrentUserId();
}
package com.worktrack.entity.auth;



@FilterDef(name = "notDeleted", parameters = @ParamDef(name = "deletedStatus", type = String.class))
@Filter(name = "notDeleted", condition = "status != :deletedStatus")
@Entity
@Table(name = "users")
public class User extends AuditableBaseEntity implements UserDetails {

    @NotBlank
    @Size(min = 3, max = 50)
    @Column(unique = true, nullable = false)
    private String username;

    @NotBlank
    @Email
    @Column(unique = true, nullable = false)
    private String email;

    @NotBlank
    @Size(min = 6)
    private String password;

    @Column(name = "full_name")
    private String fullName;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role;

    public User() {}

    public User(String username, String email, String password, String fullName, Role role) {
        this.username = username;
        this.email = email;
        this.password = password;
        this.fullName = fullName;
        this.role = role;
    }

    public String getUsername() {
        return username;
    }

    @Override
    public boolean isAccountNonExpired() {
        return UserDetails.super.isAccountNonExpired();  // default method cagirma.
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return List.of(() -> "ROLE_" + role.name());
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getFullName() {
        return fullName;
    }

    public void setFullName(String fullName) {
        this.fullName = fullName;
    }

    public Role getRole() {
        return role;
    }

    public void setRole(Role role) {
        this.role = role;
    }

}
package com.worktrack.entity.auth;

public enum Role {
    ADMIN,
    MANAGER,
    EMPLOYEE
}
package com.worktrack.entity.project;

public enum TaskStatus {
    TODO,
    IN_PROGRESS,
    DONE
}
package com.worktrack.entity.project;


@Entity
@Table(name = "task")
public class Task extends StatusAwareBaseEntity {

    @Column(nullable = false)
    private String title;

    private String description;

    @Enumerated(EnumType.STRING)
    @Column(name = "task_status", nullable = false)
    private TaskStatus taskStatus;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "project_id")
    private Project project;

    public Task(String title, String description, Project project){
        this.title = title;
        this.description = description;
        this.project = project;
    }
    public Task() {
    }

    @PrePersist
    protected void onCreateTask() {
        if (this.taskStatus == null) {
            this.taskStatus = TaskStatus.TODO;
        }
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }


    public TaskStatus getTaskStatus() {
        return taskStatus;
    }

    public void setTaskStatus(TaskStatus taskStatus) {
        this.taskStatus = taskStatus;
    }

    public Project getProject() {
        return project;
    }

    public void setProject(Project project) {
        this.project = project;
    }
}
package com.worktrack.entity.project;


@Entity
@Table(name = "project")
public class Project extends AuditableBaseEntity {

    private String name;

    private String description;

    @ManyToOne(fetch = FetchType.LAZY, optional = true)
    @JoinColumn(name = "owner_id", nullable = true)
    private User owner;

    public Project() {
    }

    public Project(String name, String description, User owner) {
        this.name = name;
        this.description = description;
        this.owner = owner;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public User getOwner() {
        return owner;
    }
    public void setOwner(User owner) {
        this.owner = owner;
    }
}
package com.worktrack.entity.base;

public enum Status {
    ACTIVE, INACTIVE, DELETED;
}
package com.worktrack.entity.base;


@MappedSuperclass
public abstract class BaseEntity extends BaseTimeEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    protected Long id;

    @Version
    @Column(name = "version")
    protected Integer version;

    public Long getId() {
        return id;
    }

    public Integer getVersion() {
        return version;
    }
}
package com.worktrack.entity.base;



@MappedSuperclass
public abstract class BaseTimeEntity {
    @Column(name = "created_at", updatable = false, nullable = false)
    protected Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    protected Instant updatedAt;

    @PrePersist
    protected void onCreate() {
        Instant now = Instant.now();
        this.createdAt = now;
        this.updatedAt = now;
    }

    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = Instant.now();
    }

    public Instant getCreatedAt() {
        return createdAt;
    }

    public Instant getUpdatedAt() {
        return updatedAt;
    }
}
package com.worktrack.entity.base;


@MappedSuperclass
public abstract class StatusAwareBaseEntity extends BaseEntity {

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    protected Status status;

    public Status getStatus() {
        return status;
    }

    public void setStatus(Status status) {
        this.status = status;
    }

    @PrePersist
    protected void onCreation() {
        if (this.status == null) {
            this.status = Status.ACTIVE;
        }
    }
}
package com.worktrack.entity.base;


@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public class AuditableBaseEntity extends StatusAwareBaseEntity {

    @CreatedBy
    @Column(name = "created_by", updatable = false)
    protected String createdBy;

    @LastModifiedBy
    @Column(name = "updated_by")
    protected String updatedBy;


    public String getCreatedBy() {
        return createdBy;
    }

    public String getUpdatedBy() {
        return updatedBy;
    }
}
package com.worktrack.annotation;


@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RequireRole {
    String[] value();            // Birden fazla rol alabilir
    String message() default ""; // Opsiyonel açıklama
    boolean loggable() default false;
}package com.worktrack.controller;



@RestController
@RequestMapping("/projects/{projectId}/tasks")
public class TaskController {
    private final TaskService taskService;

    public TaskController(TaskService taskService) {
        this.taskService = taskService;
    }

    @PostMapping
    public ResponseEntity<TaskResponse> createTask(
            @PathVariable("projectId") Long projectId,
            @RequestBody @Valid CreateTaskRequest request) {
        TaskResponse response = taskService.createTask(projectId, request);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @GetMapping
    public ResponseEntity<List<TaskResponse>> getTasks(@PathVariable Long projectId) {
        return ResponseEntity.ok(taskService.getTasksByProject(projectId));
    }

    @DeleteMapping("/{taskId}")
    public ResponseEntity<Void> deleteTask(@PathVariable Long taskId) {
        taskService.deleteTask(taskId);
        return ResponseEntity.noContent().build();
    }

}
package com.worktrack.controller;


@RestController
@RequestMapping("/api/auth")
public class AuthController {

    private final AuthService authService;

    public AuthController(AuthService authService) {
        this.authService = authService;
    }

    @PreAuthorize("isAnonymous()")
    @PostMapping("/login")
    public ResponseEntity<LoginResponse> login(@RequestBody LoginRequest request) {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        System.out.println(auth);                         // AnonymousAuthenticationToken
        System.out.println(auth.getPrincipal());          // "anonymousUser"
        System.out.println(auth.getAuthorities());


        LoginResponse response = authService.authenticate(request.username(), request.password());
        return ResponseEntity.ok(response);
    }

}
package com.worktrack.controller;



@RestController
@RequestMapping("/api/projects")
public class ProjectController {

    private final ProjectService projectService;

    public ProjectController(ProjectService projectService) {
        this.projectService = projectService;
    }

    @PreAuthorize("hasRole('MANAGER') or hasRole('ADMIN')")
    @PostMapping
    public ResponseEntity<ProjectResponse> createProject(@RequestBody @Validated(Create.class) CreateProjectRequest request) {
        return ResponseEntity
                .status(201)
                .body(projectService.createProject(request));
    }

    @GetMapping
    public ResponseEntity<Page<ProjectResponse>> getAllProjects(Pageable pageable) {
        return ResponseEntity.ok(projectService.getAllProjects(pageable));
    }

    @GetMapping("/me")
    public ResponseEntity<List<ProjectResponse>> getAllProjectsForCurrentUser() {
        return ResponseEntity.ok(projectService.getAllProjectsForCurrentUser());
    }

    @GetMapping("/{id}")
    public ResponseEntity<ProjectResponse> getProject(Long id) {
        return ResponseEntity.ok(projectService.getProjectById(id));
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void>  deleteProject(Long id) {
        return ResponseEntity
                .noContent()
                .build();
    }
}
package com.worktrack.controller;



@RestController
@RequestMapping("/api/users")
public class UserController {

    private final UserService userService;

    @Autowired
    public UserController(UserService userService) {
        this.userService = userService;
    }



    @PostMapping("/register")
    public ResponseEntity<User> register(@Valid @RequestBody UserRegistrationRequest request) {
        User registeredUser = userService.register(request);
        return ResponseEntity.ok(registeredUser);
    }

    @PutMapping("/{id}")
    public ResponseEntity<User> update(@PathVariable Long id,
                                       @Valid @RequestBody UserUpdateRequest request) {
        User updatedUser = userService.updateUser(id, request);
        return ResponseEntity.ok(updatedUser);
    }

    @PreAuthorize("hasRole('ADMIN')")
    @GetMapping
    public ResponseEntity<List<User>> getAll() {
        return ResponseEntity.ok(userService.findAll());
    }

    @GetMapping("/{id}")
    public ResponseEntity<User> getById(@PathVariable Long id) {
        return userService.findById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @PreAuthorize("hasRole('ADMIN')")
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> delete(@PathVariable Long id) {
        userService.deleteUser(id);
        return ResponseEntity.noContent().build();
    }

}
package com.worktrack.aspect;


@Aspect
@Component
public class AuthorizationAspect {
    @Before("execution(* com.worktrack.controller.AdminController.*(..))")
    public void checkIfUserIsAdmin() {
        var auth = SecurityContextHolder.getContext().getAuthentication();

        if (auth == null) {
            throw new IllegalStateException("Security context düzgün initialize edilmemiş");
        }

        boolean isAdmin = auth.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals("ROLE_ADMIN"));

        if (!isAdmin) {
            throw new AccessDeniedException("Giriş yapılmamış ya da yetkiniz yok");
        }

    }
}package com.worktrack.aspect;


@Aspect
@Component
public class PerformanceAspect {

    // Bu metot, com.worktrack.service paketindeki tüm sınıfların tüm metotlarını hedef alır
    // (* tum method tiplerini temsil eder)
    // com.worktrack.service..* tüm alt paketleri de kapsar, sadece service olsaydi com.worktrack.service.* olacaktı.
    /*
        (..)	Her sayıda, her tipte parametre
        (*)	Sadece 1 parametre, tipi fark etmez
        (String)	Sadece tek String parametre
        (*, *)	2 parametre, her tip olabilir
        (String, int)	Sadece String ve int sırasıyla
        @Around("execution(* com.worktrack.service..*.exec*(..))") exec ile baslayan tüm methodlar

     */
    @Around("execution(* com.worktrack.service..*.*(..))")
    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
        long start = System.currentTimeMillis();
        Object result = joinPoint.proceed(); // methodu çalıştır
        long duration = System.currentTimeMillis() - start;

        System.out.println(joinPoint.getSignature() + " süresi: " + duration + " ms");
        return result;
    }
}


package com.worktrack.aspect;




@Aspect
@Component
public class RequireRoleAspect {

    @Before("@annotation(requireRole)")
    public void checkUserRole(RequireRole requireRole) {
        String[] requiredRoles = requireRole.value();
        String msg = requireRole.message();
        boolean loggable = requireRole.loggable();

        if (loggable) {
            System.out.println("Rol kontrolü: " + Arrays.toString(requiredRoles));
        }

        var auth = SecurityContextHolder.getContext().getAuthentication();

        if (auth == null) {
            throw new IllegalStateException("Security context düzgün initialize edilmemiş");
        }

        Set<String> expectedAuthorities = Stream.of(requiredRoles)
                .map(role -> "ROLE_" + role)
                .collect(Collectors.toSet());

        boolean hasRole = auth.getAuthorities().stream()
                .anyMatch(a -> expectedAuthorities.contains(a.getAuthority()));

        if (!hasRole) {
            throw new AccessDeniedException("Bu işlemi yapmak için aşağıdaki rollerden en az birine sahip olmanız gerekir: " + String.join(", ", expectedAuthorities));
        }
    }
}


@Service
public class AuthServiceImp implements AuthService {

    private final JwtService jwtService;
    private final UserService userService;
    private final PasswordEncoder passwordEncoder;

    public AuthServiceImp(JwtService jwtService, UserService userService, PasswordEncoder passwordEncoder) {
        this.jwtService = jwtService;
        this.userService = userService;
        this.passwordEncoder = passwordEncoder;
    }

    public LoginResponse authenticate(String username, String password) {
        User user = userService.findByUsername(username)
                .orElseThrow(() -> new InvalidCredentialsException("User not found"));

        if (!passwordEncoder.matches(password, user.getPassword())) {
            throw new InvalidCredentialsException("Invalid password");
        }
        var generateToken = jwtService.generateToken(user);
        return new LoginResponse(generateToken.token(), generateToken.type(), generateToken.expiresAt());
    }
}


package com.worktrack.service.auth;


public interface AuthService {
    LoginResponse authenticate(String username, String rawPassword);
}
package com.worktrack.service.user;



public interface UserService {


    User register(UserRegistrationRequest request);

    User updateUser(Long id, UserUpdateRequest request);

    List<User> findAllByRole(Role role);

    Optional<User> findById(Long id);

    Optional<User> findByUsername(String username);

    Optional<User> findByEmail(String email);

    List<User> findAll();

    void deleteUser(Long id);

    boolean existsByUsername(String username);

    boolean existsByEmail(String email);

}
package com.worktrack.service.user;




@Service
public class UserServiceImpl implements UserService, UserDetailsService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;


    public UserServiceImpl(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
    }

    @Transactional
    public User register(UserRegistrationRequest request) {
        validateRegistrationRequest(request);
        String encodedPassword = getEncodedPassword(request.getPassword());
        var user = new User(request.getUsername(), request.getEmail(), encodedPassword, request.getFullName(), request.getRole());
        return userRepository.save(user);
    }

    private void validateRegistrationRequest(UserRegistrationRequest request) {
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new DuplicateUserException("Email already registered");
        }
        if (userRepository.existsByUsername(request.getUsername())) {
            throw new DuplicateUserException("Username already registered");
        }
    }

    private String getEncodedPassword(String password) {
        return passwordEncoder.encode(password);
    }



    public Optional<User> findById(Long id) {
        return userRepository.findById(id);
    }

    public Optional<User> findByUsername(String username){
        return userRepository.findByUsername(username);
    }

    public Optional<User> findByEmail(String email){
        return userRepository.findByEmail(email);
    }

    public List<User> findAll(){
        return userRepository.findAll();
    }

    public List<User> findAllByRole(Role role) {
        return userRepository.findByRole(role);
    }

    public boolean existsByUsername(String username) {
        return userRepository.existsByUsername(username);
    }

    public boolean existsByEmail(String email) {
        return userRepository.existsByEmail(email);
    }

    public void deleteUser(Long id){
        User user = userRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("User not found"));
        user.setStatus(Status.DELETED);
        userRepository.save(user);
    }


    public User updateUser(Long id, UserUpdateRequest request) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("User not found"));

        if (request.username() != null) {
            user.setUsername(request.username());
        }
        if (request.email() != null) {
            user.setEmail(request.email());
        }
        if (request.password() != null) {
            user.setPassword(getEncodedPassword(request.password()));
        }
        if (request.fullName() != null) {
            user.setFullName(request.fullName());
        }

        return userRepository.save(user);
    }


    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        return userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));
    }
}
package com.worktrack.service.project;



@Service
@Transactional(rollbackFor = Exception.class) // Exception class i icin de rollback yap normal de sadece runtime exceptionlar icin yapar
public class ProjectServiceImpl implements ProjectService {

    private final ProjectRepository projectRepository;
    private final UserService userService;
    private final AuthenticationFacade authenticationFacade;
    private final HibernateFilterManager hibernateFilterManager;

    public ProjectServiceImpl(ProjectRepository projectRepository,
                              UserService userService,
                              AuthenticationFacade authenticationFacade,
                              HibernateFilterManager hibernateFilterManager) {
        this.projectRepository = projectRepository;
        this.userService = userService;
        this.authenticationFacade = authenticationFacade;
        this.hibernateFilterManager = hibernateFilterManager;
    }

    @Override
    public ProjectResponse createProject(CreateProjectRequest request) {
        var project = new Project();
        project.setName(request.name());
        project.setDescription(request.description());
        String ownerFullName = null;
        String ownerUsername = null;
        if (request.ownerId() != null) {
            var owner = userService.findById(request.ownerId())
                    .orElseThrow(() -> new EntityNotFoundException("User not found"));
            project.setOwner(owner);
            ownerFullName = owner.getFullName();
            ownerUsername = owner.getUsername();
        } else {
            project.setOwner(null);
        }

        var createdProject = projectRepository.save(project);
        return createProjectResponse(createdProject, ownerFullName, ownerUsername);
    }

    @Override
    public List<ProjectResponse> getAllProjectsForCurrentUser() {
        hibernateFilterManager.enableNotDeletedFilter();
        var currentUser = authenticationFacade.getCurrentUserId();
        return projectRepository.findAllByOwnerIdWithOwner(currentUser)
                .stream()
                .map(project -> {
                    var owner = project.getOwner(); // DIKKAT: bunu servis icinde yapmaliyiz. controller da yapildiginda session kapanir ve LazyInitializationException firlatir.
                    return createProjectResponse(project, owner.getFullName(), owner.getUsername());
                })
                .toList();
    }



    @Override
    public Page<ProjectResponse> getAllProjects(Pageable pageable) {
        hibernateFilterManager.enableNotDeletedFilter();

        Page<Long> idsPage = projectRepository.findActiveProjectIds(pageable);
        List<Project> projects = projectRepository.findAllByIdInWithOwner(idsPage.getContent());

        List<ProjectResponse> responses = projects.stream()
                .map(project -> {
                    Optional<User> owner = Optional.ofNullable(project.getOwner());
                    var ownerFullName = owner.map(User::getFullName).orElse(null);
                    var ownerUsername = owner.map(User::getUsername).orElse(null);
                    return createProjectResponse(project, ownerFullName, ownerUsername);
                })
                .toList();

        return new PageImpl<>(responses, pageable, idsPage.getTotalElements());
    }


    @Override
    public ProjectResponse getProjectById(Long id) {
        return projectRepository.findById(id)
                .map(project -> {
                    Optional<User> owner = Optional.ofNullable(project.getOwner());
                    var ownerFullName = owner.map(User::getFullName).orElse(null);
                    var ownerUsername = owner.map(User::getUsername).orElse(null);
                    return createProjectResponse(project, ownerFullName, ownerUsername);
                })
                .orElseThrow(() -> new EntityNotFoundException("Project with id " + id + " not found"));
    }

    @Override
    public void deleteProject(Long id) {
        var project = projectRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Project with id " + id + " not found"));
        project.setStatus(Status.DELETED);
        projectRepository.save(project);
    }

    @Override
    public Optional<Project> findById(Long id) {
        return projectRepository.findById(id);
    }

    private static ProjectResponse createProjectResponse(Project createdProject, String ownerFullName, String ownerUsername) {
        return new ProjectResponse(
                createdProject.getId(),
                createdProject.getName(),
                createdProject.getDescription(),
                ownerFullName,
                ownerUsername,
                createdProject.getCreatedAt(),
                createdProject.getVersion(),
                createdProject.getStatus(),
                createdProject.getCreatedBy(),
                createdProject.getUpdatedBy()
        );
    }

}
package com.worktrack.service.project;



public interface ProjectService {
    ProjectResponse createProject(CreateProjectRequest request);

    List<ProjectResponse> getAllProjectsForCurrentUser();

    ProjectResponse getProjectById(Long id);

    void deleteProject(Long id);

    Page<ProjectResponse> getAllProjects(Pageable pageable);

    Optional<Project> findById(Long id);
}
package com.worktrack.service.project;



public interface TaskService{
    TaskResponse createTask(Long projectId, CreateTaskRequest request);
    List<TaskResponse> getTasksByProject(Long projectId);
    void deleteTask(Long taskId);
}
package com.worktrack.service.project;




@Service
public class TaskServiceImpl implements TaskService {
    private final TaskRepository taskRepository;
    private final ProjectService projectService;

    public TaskServiceImpl(TaskRepository taskRepository, ProjectService projectService) {
        this.taskRepository = taskRepository;
        this.projectService = projectService;
    }

    @Transactional
    public TaskResponse createTask(Long projectId, CreateTaskRequest request) {
        Project project = projectService.findById(projectId)
                .orElseThrow(() -> new EntityNotFoundException("Project not found"));

        Task task = new Task(
                request.title(),
                request.description(),
                project
        );
        taskRepository.save(task);
        return toResponse(task);
    }

    @Transactional(readOnly = true)
    public List<TaskResponse> getTasksByProject(Long projectId) {
        return taskRepository.findAllByProjectIdAndStatusNot(projectId, Status.DELETED)
                .stream()
                .map(this::toResponse)
                .toList();
    }

    @Transactional
    public void deleteTask(Long taskId) {
        Task task = taskRepository.findById(taskId)
                .orElseThrow(() -> new EntityNotFoundException("Task not found"));
        task.setStatus(Status.DELETED);
        // taskRepository.save(task); // DIKKAT: dirty checking, buna gerek yok cunku save yapmazsan bile delete yapar, transactional annotationu oldugu icin.
    }

    private TaskResponse toResponse(Task task) {
        return new TaskResponse(
                task.getId(),
                task.getTitle(),
                task.getDescription(),
                task.getTaskStatus()
        );
    }
}
package com.worktrack.exception.handler;


@RestControllerAdvice
public class GlobalExceptionHandler {


    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<ErrorResponse> handleAuthentication(AuthenticationException ex) {
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(new ErrorResponse("AUTHENTICATION_FAILED", ex.getMessage()));
    }

    @ExceptionHandler(InvalidCredentialsException.class)
    public ResponseEntity<ErrorResponse> handleInvalidCredentials(InvalidCredentialsException ex) {
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(new ErrorResponse("INVALID_CREDENTIAL", ex.getMessage()));
    }


    @ExceptionHandler(DuplicateUserException.class)
    public ResponseEntity<ErrorResponse> handleDuplicateUser(DuplicateUserException ex) {
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(new ErrorResponse("DUPLICATE_USER", ex.getMessage()));
    }

    @ExceptionHandler(EntityNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleEntityNotFound(EntityNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(new ErrorResponse("ENTITY_NOT_FOUND", ex.getMessage()));
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidation(MethodArgumentNotValidException ex) {
        String msg = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .findFirst()
                .map(err -> err.getField() + ": " + err.getDefaultMessage())
                .orElse("Validation failed");

        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(new ErrorResponse("VALIDATION_ERROR", msg));
    }

    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(new ErrorResponse("DB_INTEGRITY", ex.getMessage()));
    }

    @ExceptionHandler(DuplicateKeyException.class)
    public ResponseEntity<ErrorResponse> handleDuplicateKey(DuplicateKeyException ex) {
        return ResponseEntity.status(HttpStatus.CONFLICT)
                .body(new ErrorResponse("DB_DUPLICATE_KEY", ex.getMessage()));
    }

    @ExceptionHandler(CannotAcquireLockException.class)
    public ResponseEntity<ErrorResponse> handleAcquireLock(CannotAcquireLockException ex) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new ErrorResponse("DB_ACQUIRE_LOCK", ex.getMessage()));
    }

    @ExceptionHandler(AuthorizationDeniedException.class)
    public ResponseEntity<ErrorResponse> handleAuthorizationDenied(AuthorizationDeniedException ex) {
        return ResponseEntity.status(HttpStatus.FORBIDDEN)
                .body(new ErrorResponse("ACCESS_DENIED", "Bu işlemi yapmaya yetkiniz yok."));
    }

    @ExceptionHandler(QueryTimeoutException.class)
    public ResponseEntity<ErrorResponse> handleQueryTimeout(QueryTimeoutException ex) {
        return ResponseEntity.status(HttpStatus.REQUEST_TIMEOUT)
                .body(new ErrorResponse("DB_QUERY_TIMEOUT", ex.getMessage()));
    }



    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneric(Exception ex) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new ErrorResponse("INTERNAL_ERROR", "Unknown error occurred"));
    }


}

public class InvalidCredentialsException extends RuntimeException {
    public InvalidCredentialsException(String message) {
        super(message);
    }
}
package com.worktrack.exception.auth;

public class AuthenticationException extends RuntimeException {
    public AuthenticationException(String message) {
        super(message);
    }
}package com.worktrack.exception;

public class EntityNotFoundException extends RuntimeException {
    public EntityNotFoundException(String message) {
        super(message);
    }
}
package com.worktrack.exception.user;

public class DuplicateUserException extends RuntimeException {
    public DuplicateUserException(String message) {
        super(message);
    }
}
package com.worktrack.repo;



@Repository
public interface TaskRepository extends JpaRepository<Task, Long> {
    List<Task> findAllByProjectIdAndStatusNot(Long projectId, Status status);
}
package com.worktrack.repo;



@Repository
public interface ProjectRepository extends JpaRepository<Project, Long> {
    List<Project> findAllByOwnerId(Long ownerId);
    @Query("SELECT p FROM Project p JOIN FETCH p.owner WHERE p.owner.id = :ownerId")
    List<Project> findAllByOwnerIdWithOwner(@Param("ownerId") Long ownerId);

    @Query("SELECT p FROM Project p LEFT JOIN FETCH p.owner")
    List<Project> findAllWithOwner();


    @Query("SELECT p.id FROM Project p WHERE p.status = 'ACTIVE'")
    Page<Long> findActiveProjectIds(Pageable pageable);

    @Query("SELECT p FROM Project p LEFT JOIN FETCH p.owner WHERE p.id IN :ids")
    List<Project> findAllByIdInWithOwner(@Param("ids") List<Long> ids);
}
package com.worktrack.repo;



@Repository
public interface UserRepository extends JpaRepository<User, Long>, JpaSpecificationExecutor<User> {
    Optional<User> findByUsername(String username);
    Optional<User> findByEmail(String email);
    List<User> findByRole(Role role);
    boolean existsByUsername(String username);
    boolean existsByEmail(String username);
}
